import glob

autogen_file_banner = """
/*
  ^    THIS FILE WAS AUTOGENERATED
 /!\\         DO NOT MODIFY
/_'_\\ DO NOT COMPLAIN FOR UNREADABLE CODE
*/

"""

ser_root = "Obj"
ser_classes_filename = "Serialize/serializable_classes.txt"
ser_enums_filename   = "Serialize/ser_class_enums.h"
ser_saveid_filename  = "Serialize/saveid.cpp"
ser_deser_filename   = "Serialize/desertab.h"
ser_inc_filename = "Serialize/all_serializable.h"

def deser_type_enum(s):
    if s == "base":
        return "DESER_TBL_BASE"
    if s == "simple":
        return "DESER_TBL_SIMPLE"
    if s == "inplace":
        return "DESER_TBL_INPLACE"
    if s == "special":
        return "DESER_TBL_SPECIAL"
    raise "Bad deserialization type:%s" % s

class serClassEntry:
    def __init__(self, name, enum, typ, parent, file = "", extra=None):
        self.name = name
        self.altname = extra.get("altname","")
        self.nosaveid = "nosaveid" in extra
        self.file = file
        self.typ = typ
        self.enum = enum
        self.id = 0
        self.parent = parent
        self.deser_method = extra.get("deser","%s::Deserialize" % name)

    def tostr(self):
        return str(self.id) + " " + self.name + " " + self.enum + " " + self.typ


headers = glob.glob("./**/*.h", recursive=True)

new_classes = dict()

ser_inc_file = open(ser_inc_filename, "w")
ser_inc_file.write("#pragma once")
ser_inc_file.write(autogen_file_banner)


for i in range(len(headers)):
    file = open(headers[i], "r")
    lines = file.readlines()
    file.close()
    inc = False

    for j in range(len(lines)):
        if (lines[j].startswith("///SERIALIZABLE ")):
            inc = True
            extra = dict()
            data = lines[j].split()
            for s in data:
                if "=" in s:
                    param = s.split("=")
                    extra[param[0]] = param[1]
            obj_class = data[1].split(":")
            if (len(obj_class) == 1):
                obj_class.append("Obj")
            if (not new_classes.__contains__(obj_class[1])):
                new_classes[obj_class[1]] = dict()
            new_classes[obj_class[1]][obj_class[0]] = serClassEntry(obj_class[0], data[2], data[3], obj_class[1], headers[i].lstrip("./"), extra)

    if inc:
        ser_inc_file.write("#include <%s>\n" % (headers[i].lstrip("./")))

ser_inc_file.close()

print(new_classes)

old_cl_file = open(ser_classes_filename, "r")
old_class_lines = old_cl_file.readlines()
new_class_lines = []

curr_base = new_classes[ser_root]
curr_id = 1
curr_baseid = 128

extra_bases = set(new_classes.keys())
extra_bases.remove(ser_root)

for i in range(len(old_class_lines)):
    old_class_lines[i] = old_class_lines[i].rstrip("\n")

    if (old_class_lines[i].isspace()):
        continue

    if old_class_lines[i][-1] == ":":
        for name,val in curr_base.items():
            if (val.id == 0):
                if (val.typ == "base"):
                    val.id = curr_baseid
                    curr_baseid += 1
                else:
                    val.id = curr_id
                    curr_id += 1
                new_class_lines.append(val.tostr())

        name = old_class_lines[i].rstrip(":")
        curr_id = 1
        curr_baseid = 128
        if name in new_classes:
            curr_base = new_classes[name]
            extra_bases.remove(name)
    else:
        line = old_class_lines[i].split()
        if (line[1] in curr_base):
            c = curr_base[line[1]]
            c.id = int(line[0])
        if (line[3] == "base"):
            curr_baseid = int(line[0]) + 1
        else:
            curr_id = int(line[0]) + 1
    new_class_lines.append(old_class_lines[i])

while(new_class_lines[-1].isspace()):
    new_class_lines.pop()
new_class_lines.pop()

for base in extra_bases:
    new_class_lines.append(base + ":")
    curr_base_line = len(new_class_lines)
    curr_base = new_classes[base]
    for name,val in curr_base.items():
        if (val.typ == "base"):
            val.id = curr_baseid
            curr_baseid += 1
        else:
            val.id = curr_id
            curr_id += 1
        new_class_lines.append(val.tostr())

new_class_lines.append(":")

new_cl_file = open(ser_classes_filename, "w")
for line in new_class_lines:
    new_cl_file.write(line + "\n")
new_cl_file.close()



enum_file = open(ser_enums_filename, "w")
enum_file.write("#pragma once\n")
enum_file.write(autogen_file_banner)

saveid_file = open(ser_saveid_filename, "w")
saveid_file.write(autogen_file_banner)
saveid_file.write("#include <%s>\n" % ser_enums_filename)
saveid_file.write("#include <%s>\n\n" % ser_inc_filename)

deser_file = open(ser_deser_filename, "w")
deser_file.write("#pragma once\n")
deser_file.write(autogen_file_banner)
deser_file.write("#include <%s>\n" % ser_enums_filename)
deser_file.write("#include \"deser_helpers.h\"\n")
deser_file.write("#include <%s>\n\n" % ser_inc_filename)

for bname, base in new_classes.items():
    enum_file.write("enum Saved%sId { \n" % bname)
    enum_file.write("    SAVED_%s_NONE = 0,\n" % bname.upper())

    curr_desertab = []
    curr_desertab_b = []

    for cl in base.values():
        enum_file.write("    %s = %d,\n" % (cl.enum, cl.id))

        if not (cl.nosaveid):
            saveid_file.write("void %s::SaveID(DataStorageWriter &data) const {\n" % cl.name)
            if bname != ser_root:
                saveid_file.write("    %s::SaveID(data);\n" % bname)
            saveid_file.write("    WRITER_APPEND(data, saved_obj_id_t, %s);\n}\n" % cl.enum)


        if (cl.typ == "base"):
            child_desertab = "%s_deser_tbl" % cl.name.lower()
            desertab_str = "/*%d*/ {.name = \"%s\", .size = sizeof(%s)/sizeof(DeserTblEntry), .bsize = sizeof(%s)/sizeof(DeserTblBaseEntry), .e_norm = %s, .e_base = %s},\n"\
                             % (cl.id, cl.name, child_desertab, child_desertab + "_b", child_desertab, child_desertab + "_b")
            while (cl.id - 128 >= len(curr_desertab_b)):
                curr_desertab_b.append("/*%d*/ {},\n" % (len(curr_desertab_b) + 128))
            curr_desertab_b[cl.id-128] = desertab_str
        else:
            deser_func = ""
            if cl.typ == "simple":
                deser_func = ", .e_simple = %s" % cl.deser_method
            elif cl.typ == "inplace":
                deser_func = ", .e_inplace = %s" % cl.deser_method
            elif cl.typ == "special":
                deser_func = ""

            desertab_str = "/*%d*/ {.name = \"%s\", .type = %s%s},\n" % (cl.id, cl.name, deser_type_enum(cl.typ), deser_func)
            while (cl.id >= len(curr_desertab)):
                curr_desertab.append("/*%d*/ {},\n" % len(curr_desertab))
            curr_desertab[cl.id] = desertab_str

    enum_file.write("};\n")

    deser_file.write("DeserTblEntry %s_deser_tbl[] = {\n" % bname.lower())
    deser_file.writelines(curr_desertab)
    deser_file.write("};\n")

    deser_file.write("DeserTblBaseEntry %s_deser_tbl_b[] = {\n" % bname.lower())
    deser_file.writelines(curr_desertab_b)
    deser_file.write("};\n\n")


ser_root_l = ser_root.lower()
deser_file.write("size_t %s_deser_tbl_size   = sizeof(%s_deser_tbl  ) / sizeof(%s_deser_tbl[0]);\n" % (ser_root_l, ser_root_l, ser_root_l))
deser_file.write("size_t %s_deser_tbl_size_b = sizeof(%s_deser_tbl_b) / sizeof(%s_deser_tbl_b[0]);\n" % (ser_root_l, ser_root_l, ser_root_l))

enum_file.close()
saveid_file.close()
deser_file.close()
